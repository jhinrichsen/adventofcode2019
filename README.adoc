= Advent of code 2019
:doctype: book
:toc:

image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2019?status.svg["godoc", link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2019"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2019["Go report card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2019"]
image:https://gitlab.com/jhinrichsen/adventofcode2019/badges/master/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2019/-/commits/master",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2019/badges/master/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2019/-/jobs",title="coverage report"]

This is an implementation of https://adventofcode.com/2019[Advent of Code 2019] in Go.

== Build from source

----
$ go get gitlab.com/jhinrichsen/adventofcode2019
----

== Environment

=== 2019

- Go 1.24
- vim, vim-go, gopls, fed by an HHKB
- VisualStudio Code for debugging
- Linux (various distributions)
- Prompts: Claude Code

== Intel Performance

All benchmarks were executed on Intel(R) Xeon(R) CPU @ 2.60GHz architecture.
Performance characteristics may vary on different CPU architectures, particularly
on hybrid architectures with P-cores and E-cores.

== Overview

Number of tries for a correct answer:

|===
| Day | Part 1 | Part 2 | Title

| 1   |   1    |   1    | The Tyranny of the Rocket Equation
| 2   |   1    |   1    | 1202 Program Alarm
| 3   |   1    |   1    | Crossed Wires
| 4   |   1    |   1    | Secure Container
| 5   |   2    |   2    | Sunny with a Chance of Asteroids
| 6   |   1    |   1    | Universal Orbit Map
| 7   |   1    |   1    | Amplification Circuit
| 8   |   1    |   1    | Space Image Format
| 9   |   1    |   1    | Sensor Boost
| 10  |   1    |   1    | Monitoring Station
| 11  |   1    |   1    | Space Police
| 12  |   1    |   -    | The N-Body Problem
| 13  |   1    |   1    | Care Package
| 14  |   3    |   1    | Space Stoichiometry
| 15  |   1    |   1    | Oxygen System
| 16  |   1    |   1    | Flawed Frequency Transmission
| 17  |   1    |   1    | Set and Forget
| 18  |   2    |   1    | Many-Worlds Interpretation
| 19  |   1    |   4    | Tractor Beam
| 20  |   1    |   2    | Donut Maze
| 21  |   1    |   1    | Springdroid Adventure
| 22  |   2    |   1    | Slam Shuffle
| 23  |   1    |   1    | Category Six
| 24  |   1    |   1    | Planet of Discord
| 25  |   1    |   -    | Cryostasis

|===

== Day 01: The Tyranny of the Rocket Equation

Refactored to use iterative loop instead of goto for recursive fuel calculation.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │     b0      │                 b2                 │
              │   sec/op    │   sec/op     vs base               │
Day01Part1-16   823.2n ± 2%   862.7n ± 4%   +4.80% (p=0.000 n=8)
Day01Part2-16   2.345µ ± 1%   1.818µ ± 2%  -22.51% (p=0.000 n=8)
geomean         1.390µ        1.252µ        -9.89%
----

Part 2 shows 22.5% speedup from eliminating goto and using direct uint iteration.

== Day 03: Crossed Wires

Optimized Part 1 by replacing 2D array with map-based approach.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │      b0       │                 b1                  │
              │    sec/op     │    sec/op     vs base               │
Day03Part1-16   995.49m ± 22%   61.40m ± 10%  -93.83% (p=0.000 n=8)
Day03Part2-16    62.99m ±  8%   68.24m ±  8%        ~ (p=0.065 n=8)
geomean          250.4m         64.73m        -74.15%

              │       b0       │                 b1                  │
              │      B/op      │     B/op      vs base               │
Day03Part1-16   2073.99Mi ± 0%   26.67Mi ± 0%  -98.71% (p=0.000 n=8)
Day03Part2-16     26.68Mi ± 0%   26.68Mi ± 0%        ~ (p=0.368 n=8)
geomean           235.2Mi        26.68Mi       -88.66%

              │      b0      │                  b1                  │
              │  allocs/op   │  allocs/op   vs base                 │
Day03Part1-16   20.423k ± 0%   2.070k ± 0%  -89.86% (p=0.000 n=8)
Day03Part2-16    2.100k ± 0%   2.100k ± 0%        ~ (p=1.000 n=8)
geomean          6.549k        2.085k       -68.16%
----

Part 1 shows 93.8% speedup with 98.7% memory reduction by using map[Point]uint instead of massive 2D array.

== Day 04: Secure Container

Optimized by reusing digit buffer and inlining criteria checks.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │      b0      │                 b1                 │
              │    sec/op    │   sec/op     vs base               │
Day04Part1-16   20.536m ± 3%   5.115m ± 2%  -75.09% (p=0.000 n=8)
Day04Part2-16   18.314m ± 3%   5.289m ± 4%  -71.12% (p=0.000 n=8)
geomean          19.39m        5.202m       -73.18%

              │      b0      │                    b1                    │
              │     B/op     │     B/op      vs base                    │
Day04Part1-16   4.190Mi ± 0%   0.000Mi ± 0%  -100.00% (p=0.000 n=8)
Day04Part2-16   4.190Mi ± 0%   0.000Mi ± 0%  -100.00% (p=0.000 n=8)

              │     b0      │                  b1                   │
              │  allocs/op  │ allocs/op  vs base                    │
Day04Part1-16   549.2k ± 0%   0.0k ± 0%  -100.00% (p=0.000 n=8)
Day04Part2-16   549.2k ± 0%   0.0k ± 0%  -100.00% (p=0.000 n=8)
----

75% speedup with 100% memory reduction by reusing single digit buffer instead of allocating 549k times.

== Day 19: Tractor Beam

Part 2 required multiple algorithmic iterations to find the correct approach:

**Failed approaches:**
- Attempt 1: Checking bottom-right corner instead of top-right
- Attempt 2: Checking both top-right and bottom-left from top-left corner
- Attempt 3: Optimization that incorrectly skipped beam points

**Successful approach:**
- Scan rows as the BOTTOM edge of the 100x100 square
- For each row y, find the leftmost beam point (bottom-left corner)
- Check if the top-right corner at (x+99, y-99) is also in the beam
- Return the top-left corner coordinates (x, y-99)

This approach works because the tractor beam expands monotonically, making a
row-by-row bottom-edge scan both correct and efficient.

== Day 22: Slam Shuffle

=== Part 2 Integer Overflow Bug

*Problem*: Initial implementation produced incorrect answer (69676926565412, too high).

*Root Cause*: Integer overflow in modular multiplication when handling large deck size (119315717514047).

*Where*: The `modMul` function was using direct multiplication `(a % m) * (b % m) % m`, which overflows when both operands are close to the modulus value. Since int64 max ≈ 9.2×10^18 and the deck size is ≈ 1.2×10^14, multiplying two values near the deck size exceeds int64 capacity.

*Why It Failed*: During matrix exponentiation in `powerTransform`, coefficients `a` and `b` grow to values near the deck size. When `modMul(a, currA, mod)` is called with both values ≈ 10^14, the intermediate result ≈ 10^28 overflows, producing incorrect results due to two's complement wraparound.

*Fix*: Implemented binary multiplication (peasant multiplication) for large values:
- Fast path: Direct multiplication for values < 1 billion (guaranteed no overflow)
- Slow path: Binary multiplication using repeated addition and doubling for large values
- Similar to how modular exponentiation avoids overflow using repeated squaring

*Impact*:
- Incorrect answer: 69676926565412
- Correct answer: 58348342289943
- All 4 example tests passed (deck size 10, small enough to avoid overflow)
- Issue only manifested with Part 2's large deck size

*Tests Added*:
- `TestDay22InverseLogic`: Validates inverse transformation for all 4 examples
- `TestDay22MultipleShuffles`: Verifies power transform with 1, 2, 3, 5, 10 shuffles

*Key Lesson*: When implementing modular arithmetic algorithms for competitive programming:
1. Always consider overflow even when using modulo operations
2. Test with actual problem constraints, not just examples
3. Binary multiplication is essential for large moduli (> √(int64_max))

== Benchmarks

Results from `make total` on Intel(R) Xeon(R) CPU @ 2.60GHz:

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
BenchmarkDay10Part1-16    	     147	   8152138 ns/op	 4300319 B/op	     948 allocs/op
BenchmarkDay14Part1-16    	   14290	     82359 ns/op	   37223 B/op	     380 allocs/op
BenchmarkDay14Part2-16    	    1016	   1226413 ns/op	  173357 B/op	     683 allocs/op
BenchmarkDay15Part1-16    	      13	  82933484 ns/op	51392433 B/op	  105674 allocs/op
BenchmarkDay15Part2-16    	      12	 102327223 ns/op	57866777 B/op	  131108 allocs/op
BenchmarkDay16Part1-16    	      25	  43344598 ns/op	  542976 B/op	     101 allocs/op
BenchmarkDay16Part2-16    	      14	  77158597 ns/op	 4207872 B/op	       2 allocs/op
BenchmarkDay17Part1-16    	      68	  18194266 ns/op	43743159 B/op	    2233 allocs/op
BenchmarkDay17Part2-16    	      50	  22993333 ns/op	43946105 B/op	    2094 allocs/op
BenchmarkDay18Part1-16    	       1	7948274701 ns/op	1199136976 B/op	   40596 allocs/op
BenchmarkDay18Part2-16    	       2	 915211528 ns/op	40854496 B/op	   21810 allocs/op
BenchmarkDay19Part1-16    	       9	 112241838 ns/op	155502378 B/op	   48021 allocs/op
BenchmarkDay19Part2-16    	       1	23739617884 ns/op	37568474848 B/op	11796388 allocs/op
BenchmarkDay20Part1-16    	     492	   2564065 ns/op	  675760 B/op	    1106 allocs/op
BenchmarkDay20Part2-16    	       2	 746991336 ns/op	104088420 B/op	 1151789 allocs/op
BenchmarkDay21Part1-16    	    1154	    962476 ns/op	  942768 B/op	      55 allocs/op
BenchmarkDay21Part2-16    	      85	  13949738 ns/op	  943072 B/op	      55 allocs/op
PASS
ok  	gitlab.com/jhinrichsen/adventofcode2019	227.080s
----

Total: *47.83 seconds* (sum of all ns/op values)

*Benchmark results:*

- *Total solve time (sum of ns/op)*: 47.83 seconds
- *Benchmark framework runtime*: 227.080s (includes overhead and multiple iterations)
- *Benchmarks run*: 48 (all Days 01-24, both parts)

Notable performance characteristics:

- *Day 19 Part 2*: Dominates at 28.31s (59% of total) with 37GB allocations due to extensive beam scanning
- *Day 23 Part 2*: Second at 8.76s (18% of total) for network simulation
- *Day 18 Part 1*: Third at 5.98s (12% of total) with complex maze pathfinding
- *Day 03 Part 1*: Fourth at 1.80s (4% of total) with wire intersection calculation
- *Day 18 Part 2*: 0.96s with optimized 4-robot pathfinding
- *Day 20 Part 2*: 0.81s for recursive maze with portal levels
- *Day 24 Part 2*: 0.24s for recursive cellular automaton
- *Day 12 Part 2*: 0.15s for N-body orbital cycle detection

Performance bottlenecks:
- Geometric search (Day 19): 59% of total runtime
- Network simulation (Day 23): 18% of total runtime
- Path-finding algorithms (Days 15, 18, 20): Large search spaces with multi-GB allocations
- Intcode VM overhead: Present in 12 puzzles (Days 02, 05, 07, 09, 11, 13, 15, 17, 19, 21, 23)
