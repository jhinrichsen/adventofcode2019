= Advent of code 2019
:doctype: book
:toc:

image:https://godoc.org/gitlab.com/jhinrichsen/adventofcode2019?status.svg["godoc", link="https://godoc.org/gitlab.com/jhinrichsen/adventofcode2019"]
image:https://goreportcard.com/badge/gitlab.com/jhinrichsen/adventofcode2019["Go report card", link="https://goreportcard.com/report/gitlab.com/jhinrichsen/adventofcode2019"]
image:https://gitlab.com/jhinrichsen/adventofcode2019/badges/master/pipeline.svg[link="https://gitlab.com/jhinrichsen/adventofcode2019/-/commits/master",title="pipeline status"]
image:https://gitlab.com/jhinrichsen/adventofcode2019/badges/master/coverage.svg[link="https://gitlab.com/jhinrichsen/adventofcode2019/-/jobs",title="coverage report"]

This is an implementation of https://adventofcode.com/2019[Advent of Code 2019] in Go.

== Build from source

----
$ go get gitlab.com/jhinrichsen/adventofcode2019
----

== Environment

=== 2019

- Go 1.24
- vim, vim-go, gopls, fed by an HHKB
- VisualStudio Code for debugging
- Linux (various distributions)
- Prompts: Claude Code

== Intel Performance

All benchmarks were executed on Intel(R) Xeon(R) CPU @ 2.60GHz architecture.
Performance characteristics may vary on different CPU architectures, particularly
on hybrid architectures with P-cores and E-cores.

== Overview

Number of tries for a correct answer:

|===
| Day | Part 1 | Part 2 | Title

| 1   |   1    |   1    | The Tyranny of the Rocket Equation
| 2   |   1    |   1    | 1202 Program Alarm
| 3   |   1    |   1    | Crossed Wires
| 4   |   1    |   1    | Secure Container
| 5   |   2    |   2    | Sunny with a Chance of Asteroids
| 6   |   1    |   1    | Universal Orbit Map
| 7   |   1    |   1    | Amplification Circuit
| 8   |   1    |   1    | Space Image Format
| 9   |   1    |   1    | Sensor Boost
| 10  |   1    |   1    | Monitoring Station
| 11  |   1    |   1    | Space Police
| 12  |   1    |   -    | The N-Body Problem
| 13  |   1    |   1    | Care Package
| 14  |   3    |   1    | Space Stoichiometry
| 15  |   1    |   1    | Oxygen System
| 16  |   1    |   1    | Flawed Frequency Transmission
| 17  |   1    |   1    | Set and Forget
| 18  |   2    |   1    | Many-Worlds Interpretation
| 19  |   1    |   4    | Tractor Beam
| 20  |   1    |   2    | Donut Maze
| 21  |   1    |   1    | Springdroid Adventure
| 22  |   2    |   1    | Slam Shuffle
| 23  |   1    |   1    | Category Six
| 24  |   1    |   1    | Planet of Discord
| 25  |   1    |   -    | Cryostasis

|===

== Day 01: The Tyranny of the Rocket Equation

Refactored to use iterative loop instead of goto for recursive fuel calculation.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │     b0      │                 b2                 │
              │   sec/op    │   sec/op     vs base               │
Day01Part1-16   823.2n ± 2%   862.7n ± 4%   +4.80% (p=0.000 n=8)
Day01Part2-16   2.345µ ± 1%   1.818µ ± 2%  -22.51% (p=0.000 n=8)
geomean         1.390µ        1.252µ        -9.89%
----

Part 2 shows 22.5% speedup from eliminating goto and using direct uint iteration.

== Day 03: Crossed Wires

Optimized Part 1 by replacing 2D array with map-based approach.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │      b0       │                 b1                  │
              │    sec/op     │    sec/op     vs base               │
Day03Part1-16   995.49m ± 22%   61.40m ± 10%  -93.83% (p=0.000 n=8)
Day03Part2-16    62.99m ±  8%   68.24m ±  8%        ~ (p=0.065 n=8)
geomean          250.4m         64.73m        -74.15%

              │       b0       │                 b1                  │
              │      B/op      │     B/op      vs base               │
Day03Part1-16   2073.99Mi ± 0%   26.67Mi ± 0%  -98.71% (p=0.000 n=8)
Day03Part2-16     26.68Mi ± 0%   26.68Mi ± 0%        ~ (p=0.368 n=8)
geomean           235.2Mi        26.68Mi       -88.66%

              │      b0      │                  b1                  │
              │  allocs/op   │  allocs/op   vs base                 │
Day03Part1-16   20.423k ± 0%   2.070k ± 0%  -89.86% (p=0.000 n=8)
Day03Part2-16    2.100k ± 0%   2.100k ± 0%        ~ (p=1.000 n=8)
geomean          6.549k        2.085k       -68.16%
----

Part 1 shows 93.8% speedup with 98.7% memory reduction by using map[Point]uint instead of massive 2D array.

== Day 04: Secure Container

Optimized by reusing digit buffer and inlining criteria checks.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
              │      b0      │                 b1                 │
              │    sec/op    │   sec/op     vs base               │
Day04Part1-16   20.536m ± 3%   5.115m ± 2%  -75.09% (p=0.000 n=8)
Day04Part2-16   18.314m ± 3%   5.289m ± 4%  -71.12% (p=0.000 n=8)
geomean          19.39m        5.202m       -73.18%

              │      b0      │                    b1                    │
              │     B/op     │     B/op      vs base                    │
Day04Part1-16   4.190Mi ± 0%   0.000Mi ± 0%  -100.00% (p=0.000 n=8)
Day04Part2-16   4.190Mi ± 0%   0.000Mi ± 0%  -100.00% (p=0.000 n=8)

              │     b0      │                  b1                   │
              │  allocs/op  │ allocs/op  vs base                    │
Day04Part1-16   549.2k ± 0%   0.0k ± 0%  -100.00% (p=0.000 n=8)
Day04Part2-16   549.2k ± 0%   0.0k ± 0%  -100.00% (p=0.000 n=8)
----

75% speedup with 100% memory reduction by reusing single digit buffer instead of allocating 549k times.

== Day 10: Monitoring Station

Optimized asteroid visibility detection by replacing expensive floating-point operations with integer-based GCD normalization.

.Key changes
- Replaced `complex128` coordinates with integer `Asteroid{X, Y int}` struct
- Part 1: GCD-based direction normalization instead of `cmplx.Polar()` and `math.Atan2()`
- Part 2: Squared distance for sorting (avoiding `math.Sqrt()`), simplified vaporization algorithm
- Eliminated `cmplx.Abs()` calls in hot path

.Performance impact
----
              │     b2      │                 b3                 │
              │   sec/op    │   sec/op     vs base               │
Day10Part1-16   7.856m ± 4%   5.703m ± 5%  -27.40% (p=0.000 n=8)
Day10Part2-16   8.138m ± 2%   5.833m ± 3%  -28.33% (p=0.000 n=8)

              │     b2      │                 b3                  │
              │  allocs/op  │ allocs/op   vs base                 │
Day10Part1-16    948.0 ± 0%   948.0 ± 0%        ~ (p=1.000 n=8)
Day10Part2-16   1606.0 ± 0%   971.0 ± 0%  -39.54% (p=0.000 n=8)
----

== Day 12: The N-Body Problem

Optimized cycle detection by preallocating map capacity to reduce memory reallocations.

.Key changes
- Preallocated history map with capacity 100,000 instead of default zero capacity
- Reduced map growth allocations during cycle detection
- Part 1 already optimal (91µs, 0 allocations)

.Performance impact
----
Part2 Memory:     126MB → 94MB   (25% reduction)
Part2 Allocations: 3136 → 2317   (26% reduction)
----

== Day 15: Oxygen System

Optimized maze exploration by eliminating queue slice reallocation overhead.

.Key changes
- Replaced `queue = queue[1:]` pattern with index-based dequeue in three functions
- Preallocated queues with reasonable capacity (100-1000 elements)
- Fixed in `exploreAndFindOxygen`, `findPath`, and `fillWithOxygen` functions

.Performance impact
----
Part1 Allocations: 105,674 → 64,341 (39% reduction)
Part2 Time:        114ms → 98ms    (14% faster)
Part2 Allocations: 131,107 → 81,119 (38% reduction)
----

== Day 18: Many-Worlds Interpretation

Optimized BFS queue operations by eliminating repeated slice reallocations.

.Key changes
- Replaced `queue = queue[1:]` pattern with index-based dequeue using `head` pointer
- Preallocated queue and visited map with reasonable initial capacity
- Applied fix to both Part 1 (solvePart1) and helper function (bfsFrom)

.Performance impact
----
Part1 Time:        7.7s → 4.0s    (48% faster)
Part1 Allocations: 40,596 → 32,872 (19% reduction)
----

== Day 19: Tractor Beam

Part 2 required multiple algorithmic iterations to find the correct approach:

*Failed approaches:*
- Attempt 1: Checking bottom-right corner instead of top-right
- Attempt 2: Checking both top-right and bottom-left from top-left corner
- Attempt 3: Optimization that incorrectly skipped beam points

*Successful approach:*
- Scan rows as the BOTTOM edge of the 100x100 square
- For each row y, find the leftmost beam point (bottom-left corner)
- Check if the top-right corner at (x+99, y-99) is also in the beam
- Return the top-left corner coordinates (x, y-99)

This approach works because the tractor beam expands monotonically, making a
row-by-row bottom-edge scan both correct and efficient.

=== Performance Optimizations

Optimized by eliminating channel overhead and implementing direct IntCode execution.

----
goos: linux
goarch: amd64
pkg: gitlab.com/jhinrichsen/adventofcode2019
cpu: Intel(R) Xeon(R) CPU @ 2.60GHz
                │       b0        │                  b1                   │
                │     sec/op      │    sec/op      vs base                │
Day19Part1-16     127.1m ±  0%     76.5m ± 10%   -39.81% (p=0.000 n=1+8)
Day19Part2-16     25478.9m ±  0%    103.5m ±  6%   -99.59% (p=0.000 n=1+8)
geomean           1.801            88.88m         -95.07%

                │        b0        │                  b1                   │
                │       B/op       │      B/op       vs base               │
Day19Part1-16     155.5Mi ±  0%    147.6Mi ± 0%    -5.08% (p=0.000 n=1+8)
Day19Part2-16     35.0Gi ±  0%      0.2Gi ± 0%   -99.44% (p=0.000 n=1+8)
geomean           2.333Gi          492.5Mi        -78.91%

                │      b0       │                  b1                   │
                │   allocs/op   │  allocs/op   vs base                  │
Day19Part1-16     48.008k ±  0%   40.509k ± 0%   -15.62% (p=0.000 n=1+8)
Day19Part2-16     11796.278k ± 0%   55.234k ± 0%   -99.53% (p=0.000 n=1+8)
geomean           756.4k           47.94k         -93.66%
----

Key optimizations:

1. *Direct IntCode execution*: Replaced channel-based Day5 processor with inline `runBeamTest` function
   - Eliminated goroutine and channel synchronization overhead
   - Reduced allocations by avoiding channel buffers

2. *Incremental leftX tracking*: Track leftmost beam x-coordinate from previous row
   - Beam expands monotonically, so no need to search from x=0 each iteration
   - Significantly reduces redundant beam tests in Part 2

3. *Memory efficiency*: Inline execution uses stack allocation instead of heap
   - Part 2 reduced from 35GB to 200MB (99.4% reduction)
   - Part 2 allocations reduced from 11.8M to 55K (99.5% reduction)

Results: Part 2 speedup of 245x (from 25.5s to 0.104s), making Day 19 no longer the dominant bottleneck.


== Day 22: Slam Shuffle

=== Part 2 Integer Overflow Bug

*Problem*: Initial implementation produced incorrect answer (69676926565412, too high).

*Root Cause*: Integer overflow in modular multiplication when handling large deck size (119315717514047).

*Where*: The `modMul` function was using direct multiplication `(a % m) * (b % m) % m`, which overflows when both operands are close to the modulus value. Since int64 max ≈ 9.2×10^18 and the deck size is ≈ 1.2×10^14, multiplying two values near the deck size exceeds int64 capacity.

*Why It Failed*: During matrix exponentiation in `powerTransform`, coefficients `a` and `b` grow to values near the deck size. When `modMul(a, currA, mod)` is called with both values ≈ 10^14, the intermediate result ≈ 10^28 overflows, producing incorrect results due to two's complement wraparound.

*Fix*: Implemented binary multiplication (peasant multiplication) for large values:
- Fast path: Direct multiplication for values < 1 billion (guaranteed no overflow)
- Slow path: Binary multiplication using repeated addition and doubling for large values
- Similar to how modular exponentiation avoids overflow using repeated squaring

*Impact*:
- Incorrect answer: 69676926565412
- Correct answer: 58348342289943
- All 4 example tests passed (deck size 10, small enough to avoid overflow)
- Issue only manifested with Part 2's large deck size

*Tests Added*:
- `TestDay22InverseLogic`: Validates inverse transformation for all 4 examples
- `TestDay22MultipleShuffles`: Verifies power transform with 1, 2, 3, 5, 10 shuffles

*Key Lesson*: When implementing modular arithmetic algorithms for competitive programming:
1. Always consider overflow even when using modulo operations
2. Test with actual problem constraints, not just examples
3. Binary multiplication is essential for large moduli (> √(int64_max))

== Benchmarks

Results from `make total` on Intel(R) Xeon(R) CPU @ 2.60GHz:

[source]
----
include::benches/linux-amd64-IntelR_XeonR.txt[]
----
== SAST (Static Application Security Testing)

This project uses custom SAST tooling in GitLab CI, optimized for the free tier.

=== GitLab Free Tier Limitations

GitLab's built-in SAST features (Security Dashboard, vulnerability management, merge request security widgets) require the Ultimate tier. On the free tier, SAST scans can run but results are only available as downloadable JSON artifacts.

=== Current Setup

Our CI pipeline uses:

- Code Quality Reports: golangci-lint → JSON → banyansecurity/golint-convert → CodeClimate JSON format
  * Displays findings in merge request Code Quality widget (available in free tier since GitLab 13.2)
  * Shows code quality degradations/improvements directly in MRs

- Test Reports: go-junit-report/v2 → JUnit XML format
  * Integrates test results into GitLab's test report UI

- Coverage Reports: gocover-cobertura → Cobertura XML format  
  * Shows coverage metrics and trends in merge requests

- Vulnerability Scanning: govulncheck (periodic, scheduled pipeline)
  * Scans for known vulnerabilities in Go dependencies
  * Runs on a schedule to catch newly disclosed vulnerabilities
  * Results available as JSON artifacts (no UI on free tier)

=== Note on Deprecation

GitLab deprecated its built-in CodeClimate scanning template in version 17.3 (planned removal in 19.0). This only affects GitLab's bundled scanning engine. Custom pipelines that generate CodeClimate-format JSON (like ours) continue to work and are the recommended approach for free tier users.

The Code Quality widget will continue to display results from custom CodeClimate JSON reports.
